#!/usr/bin/python3

import asyncio
import argparse
import logging
import signal
import os
import sys
import socket


DEFAULT_GEOMETRY = "1000x750"

log = logging.getLogger()

class Runner:
    def __init__(self, args):
        self.args = args
        self.display_number = 100 # TODO: generate a unique display number
        self.loop = asyncio.get_event_loop()

    def create_future_for_signal(self, signum=signal.SIGINT):
        """
        Create a future that is set to True when the given signal is received
        """
        signal_received = self.loop.create_future()
        def _on_signal():
            self.loop.remove_signal_handler(signum)
            signal_received.set_result(True)
        self.loop.add_signal_handler(signum, _on_signal)
        return signal_received

    @asyncio.coroutine
    def start_xserver(self):
        # When starting an X server, if the X server sees that SIGUSR1 is
        # ignored, it sends SIGUSR1 to the parent process when it is ready to
        # accept connections. We wait until we receive SIGUSR1 before declaring
        # that the X server has been started.

        server_ready = self.create_future_for_signal(signal.SIGUSR1)

        def _before_xserver():
            signal.signal(signal.SIGUSR1, signal.SIG_IGN)
            signal.signal(signal.SIGINT, signal.SIG_IGN)
        self.xserver = yield from asyncio.create_subprocess_exec(
                "Xtigervnc",
                "-geometry", self.args.geometry,
                "-desktop", self.args.title,
                "-SecurityTypes", "None",
                "-localhost",
                ":{}".format(self.display_number),
                preexec_fn=_before_xserver,
        )

        yield from server_ready


    @asyncio.coroutine
    def start_xclient(self):
        env = dict(os.environ)
        env["DISPLAY"] = ":{}".format(self.display_number)
        def _preexec():
            signal.signal(signal.SIGINT, signal.SIG_IGN)
        self.xclient = yield from asyncio.create_subprocess_exec(
                *self.args.cmd,
                preexec_fn=_preexec,
                env=env,
        )

    @asyncio.coroutine
    def start_webserver(self):
        def _preexec():
            signal.signal(signal.SIGINT, signal.SIG_IGN)
        self.webserver = yield from asyncio.create_subprocess_exec(
                "websockify",
                "--web", "/usr/share/novnc/",
                str(self.args.port),
                "localhost:{}".format(5900 + self.display_number),
                preexec_fn=_preexec,
        )


    @asyncio.coroutine
    def wait_for_listen(self, host, port):
        sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)

        try:
            while True:
                try:
                    yield from self.loop.sock_connect(sock, (host, port))
                except ConnectionRefusedError:
                    yield from asyncio.sleep(0.2)
                else:
                    return
        finally:
            sock.close()


    @asyncio.coroutine
    def start(self):
        log.info("Starting X server")
        yield from self.start_xserver()

        log.info("Starting X client")
        yield from self.start_xclient()

        log.info("Starting web server")
        yield from self.start_webserver()

        log.info("Waiting for web server to start")
        yield from self.wait_for_listen("localhost", self.args.port)

        connect_url = "http://localhost:{port}/vnc.html?host=localhost&port={port}&autoconnect=true".format(port=self.args.port)
        log.info("Connect using %s", connect_url)

        log.info("Ready for connections, interrupt with ^C")
        yield from self.create_future_for_signal(signal.SIGINT)

        log.info("Terminating")
        self.xclient.terminate()
        self.xserver.terminate()
        self.webserver.terminate()

        log.info("Waiting")
        yield from self.xclient.wait()
        yield from self.xserver.wait()
        yield from self.webserver.wait()


def main():
    parser = argparse.ArgumentParser(
            description="start X client on a private X server exported via VNC on the web",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")
    parser.add_argument("--geometry", action="store", default=DEFAULT_GEOMETRY, help="X display geometry")
    parser.add_argument("--title", action="store", default="Desktop session", help="desktop session title")
    parser.add_argument("--port", action="store", type=int, default=6080, help="websocket server port")
    parser.add_argument("cmd", nargs="+", help="command and arguments to run")

    args = parser.parse_args()

    log_format = "%(asctime)-15s %(levelname)s %(message)s"
    level = logging.WARN
    if args.debug:
        level = logging.DEBUG
    elif args.verbose:
        level = logging.INFO
    logging.basicConfig(level=level, stream=sys.stderr, format=log_format)

    runner = Runner(args)

    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(runner.start())
    finally:
        loop.close()


if __name__ == "__main__":
    main()
