#!/usr/bin/python3
import asyncio
import argparse
import logging
import signal
import os
import sys
import shutil
import shlex
import json
import socket
from unitd import SimpleProcess
from unitd.processpool import ProcessPool
from unitd.signals import create_future_for_signal

XSERVERS = ("Xtigervnc", "Xvnc4")
DEFAULT_GEOMETRY = "1000x750"
DEFAULT_DISPLAY = 10

log = logging.getLogger()


class Fail(RuntimeError):
    pass


class Xserver(SimpleProcess):
    def __init__(self, cmdline, loop=None):
        super().__init__("xserver", service={
            "ExecStart": [cmdline],
        }, preexec_fn=self._before_xserver, loop=loop)

    def _before_xserver(self):
        signal.signal(signal.SIGUSR1, signal.SIG_IGN)
        signal.signal(signal.SIGINT, signal.SIG_IGN)

    @asyncio.coroutine
    def _start(self):
        # When starting an X server, if the X server sees that SIGUSR1 is
        # ignored, it sends SIGUSR1 to the parent process when it is ready to
        # accept connections. We wait until we receive SIGUSR1 before declaring
        # that the X server has been started.

        server_ready = create_future_for_signal(signal.SIGUSR1, loop=self.loop)
        yield from super()._start()
        log.debug("%s:X server starting", self.log_tag)

        # Also monitor for the x server quitting, otherwise in case of an issue
        # (wrong command line, or display number already in use) we never get
        # the signal and we wait forever
        done, pending = yield from asyncio.wait((
            server_ready,
            self.proc.wait()), return_when=asyncio.FIRST_COMPLETED)
        for p in pending:
            p.cancel()
        if self.proc.returncode is not None:
            raise Fail("Failed to start the X server")
        log.debug("%s:X server started", self.log_tag)


class Websockify(SimpleProcess):
    def __init__(self, cmdline, listen_port, loop=None):
        super().__init__("websockify", service={
            "ExecStart": [cmdline],
        }, preexec_fn=self._preexec)
        self.listen_port = listen_port

    def _preexec(self):
        signal.signal(signal.SIGINT, signal.SIG_IGN)

    @asyncio.coroutine
    def _start(self):
        yield from super()._start()
        yield from self._wait_for_listen("127.0.0.1", self.listen_port)

    @asyncio.coroutine
    def _wait_for_listen(self, host, port):
        """
        Try to connect to a (host, port) until something starts listening on it
        """
        sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
        try:
            while True:
                try:
                    yield from self.loop.sock_connect(sock, (host, port))
                except ConnectionRefusedError:
                    yield from asyncio.sleep(0.2)
                else:
                    return
        finally:
            sock.close()


class RemoteApplication:
    """
    Run an application inside a private VNC server, and export the VNC
    connection to it over websocket
    """
    def __init__(self,
                 cmdline, websocket_listen_port,
                 desktop_title="Remote application",
                 desktop_geometry=DEFAULT_GEOMETRY,
                 desktop_display=DEFAULT_DISPLAY):
        self.cmdline = cmdline
        self.websocket_listen_port = websocket_listen_port
        self.desktop_title = desktop_title
        self.desktop_geometry = desktop_geometry

        for xserver in XSERVERS:
            self.xserver_path = shutil.which(xserver)
            log.debug("X server lookup: tried %s, got %s", xserver, self.xserver_path)
            if self.xserver_path is not None:
                break
        log.debug("X server lookup: selected X server %s", self.xserver_path)
        if self.xserver_path is None:
            raise Fail("X server not found. Tried: " + ", ".join(XSERVERS))

        self.display_number = DEFAULT_DISPLAY # TODO: generate a unique display number
        self.loop = asyncio.get_event_loop()
        self.xserver = self._create_xserver()
        self.xclient = self._create_xclient()
        self.websockify = self._create_websockify()
        self.started = asyncio.wait((
            self.xserver.started,
            self.xclient.started,
            self.websockify.started,
        ), loop=self.loop, return_when=asyncio.ALL_COMPLETED)

    def _create_xserver(self):
        """
        Start the X server and return when it is ready to accept connections
        from X clients
        """
        cmd = (self.xserver_path, "-ac",
               "-geometry", self.desktop_geometry,
               "-desktop", self.desktop_title,
               "-SecurityTypes", "None",
               "-localhost",
               ":{}".format(self.display_number))
        return Xserver(cmd, loop=self.loop)

    def _create_xclient(self):
        """
        Start the X client
        """
        env = dict(os.environ)
        env["DISPLAY"] = ":{}".format(self.display_number)
        def _preexec():
            signal.signal(signal.SIGINT, signal.SIG_IGN)
        return SimpleProcess("xclient", service={
            "ExecStart": [self.cmdline],
        }, preexec_fn=_preexec, env=env, loop=self.loop)

    def _create_websockify(self):
        """
        Start websockify to export the X client connection via a websocket
        server
        """
        cmd = ("websockify",
               "--run-once",
               "--web", "/usr/share/novnc/",
               str(self.websocket_listen_port),
               "localhost:{}".format(5900 + self.display_number))
        return Websockify(cmd, self.websocket_listen_port, loop=self.loop)

    @asyncio.coroutine
    def run(self):
        """
        Wait until any one of the X server, X application or websocket proxy
        quits, then make sure all the others quit as well
        """
        pool = ProcessPool(loop=self.loop)
        pool.set_quit_signal(signal.SIGINT)
        yield from pool.start_sync(self.xserver)
        yield from pool.start_sync(self.xclient)
        yield from pool.start_sync(self.websockify)
        yield from pool.run()


def main():
    parser = argparse.ArgumentParser(
            description="start X client on a private X server exported via VNC on the web",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")
    parser.add_argument("--geometry", action="store", default=DEFAULT_GEOMETRY, help="X display geometry")
    parser.add_argument("--display", action="store", type=int, default=DEFAULT_DISPLAY, help="X display number")
    parser.add_argument("--title", action="store", default="Desktop session", help="desktop session title")
    parser.add_argument("--port", action="store", type=int, default=6080, help="websocket server port")
    parser.add_argument("--open", action="store_true", help="open application in browser")
    parser.add_argument("--half-daemon", action="store_true", help="setsid, chdir, close file descriptors, but do not fork")
    parser.add_argument("cmd", nargs="+", help="command and arguments to run")

    args = parser.parse_args()

    log_format = "%(asctime)-15s %(levelname)s %(message)s"
    level = logging.WARN
    if args.debug:
        level = logging.DEBUG
    elif args.verbose:
        level = logging.INFO
    logging.basicConfig(level=level, stream=sys.stderr, format=log_format)

    if args.half_daemon:
        try:
            os.setsid()
        except PermissionError:
            pass
        os.chdir("/")

    runner = RemoteApplication(
            cmdline=args.cmd,
            websocket_listen_port=args.port,
            desktop_title=args.title,
            desktop_geometry=args.geometry,
            desktop_display=args.display)

    loop = asyncio.get_event_loop()
    try:
        log.debug("Starting processes")
        task = loop.create_task(runner.run())

        loop.run_until_complete(runner.started)
        log.info("Ready for connections, interrupt with ^C")

        connect_url = "http://localhost:{port}/vnc.html?host=localhost&port={port}&autoconnect=true".format(port=runner.websocket_listen_port)
        log.info("Connect using %s", connect_url)

        json.dump({
            "url": connect_url,
        }, sys.stdout)
        sys.stdout.flush()

        if args.open:
            import webbrowser
            webbrowser.open(connect_url)

        if args.half_daemon:
            devnull_fd = os.open("/dev/null", os.O_RDWR)
            os.dup2(devnull_fd, 0)
            os.dup2(devnull_fd, 1)
            os.dup2(devnull_fd, 2)

        loop.run_until_complete(task)
    finally:
        loop.close()


if __name__ == "__main__":
    try:
        main()
    except Fail as e:
        print(e, file=sys.stderr)
        sys.exit(1)
