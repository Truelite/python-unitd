#!/usr/bin/python3
import asyncio
import argparse
import logging
import signal
import os
import sys
import shutil
import shlex
import json
import socket
from unitd import SimpleProcess
from unitd.processpool import ProcessPool
from unitd.signals import create_future_for_signal
import unitd.config


XSERVERS = ("Xtigervnc", "Xvnc4")
DEFAULT_GEOMETRY = "1000x750"
DEFAULT_DISPLAY = 10

log = logging.getLogger()


class Fail(RuntimeError):
    pass


class Xserver(SimpleProcess):
    def __init__(self, cmdline, loop=None):
        config = unitd.config.Config()
        config.service.syslog_identifier = "xserver"
        config.service.exec_start.append(cmdline)
        super().__init__(config, preexec_fn=self._before_xserver, loop=loop)
        self.server_ready = None

    def _before_xserver(self):
        signal.signal(signal.SIGUSR1, signal.SIG_IGN)
        signal.signal(signal.SIGINT, signal.SIG_IGN)

    @asyncio.coroutine
    def _start(self):
        # When starting an X server, if the X server sees that SIGUSR1 is
        # ignored, it sends SIGUSR1 to the parent process when it is ready to
        # accept connections. We wait until we receive SIGUSR1 before declaring
        # that the X server has been started.

        self.server_ready = create_future_for_signal(signal.SIGUSR1, loop=self.loop)
        yield from super()._start()

    @asyncio.coroutine
    def _confirm_start(self):
        yield from super()._confirm_start()
        yield from self.server_ready


class Websockify(SimpleProcess):
    def __init__(self, cmdline, listen_port, loop=None):
        config = unitd.config.Config()
        config.service.syslog_identifier = "websocksify"
        config.service.exec_start.append(cmdline)
        super().__init__(config, preexec_fn=self._preexec)
        self.listen_port = listen_port

    def _preexec(self):
        signal.signal(signal.SIGINT, signal.SIG_IGN)

    @asyncio.coroutine
    def _confirm_start(self):
        yield from super()._confirm_start()
        yield from self._wait_for_listen("127.0.0.1", self.listen_port)

    @asyncio.coroutine
    def _wait_for_listen(self, host, port):
        """
        Try to connect to a (host, port) until something starts listening on it
        """
        sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
        try:
            while True:
                try:
                    yield from self.loop.sock_connect(sock, (host, port))
                except ConnectionRefusedError:
                    yield from asyncio.sleep(0.2)
                else:
                    return
        finally:
            sock.close()


class RemoteApplication:
    """
    Run an application inside a private VNC server, and export the VNC
    connection to it over websocket
    """
    def __init__(self, config,
                 websocket_listen_port,
                 desktop_title="Remote application",
                 desktop_geometry=DEFAULT_GEOMETRY,
                 desktop_display=DEFAULT_DISPLAY):
        self.config = config
        self.websocket_listen_port = websocket_listen_port
        self.desktop_title = desktop_title
        self.desktop_geometry = desktop_geometry

        for xserver in XSERVERS:
            self.xserver_path = shutil.which(xserver)
            log.debug("X server lookup: tried %s, got %s", xserver, self.xserver_path)
            if self.xserver_path is not None:
                break
        log.debug("X server lookup: selected X server %s", self.xserver_path)
        if self.xserver_path is None:
            raise Fail("X server not found. Tried: " + ", ".join(XSERVERS))

        self.display_number = DEFAULT_DISPLAY # TODO: generate a unique display number
        self.loop = asyncio.get_event_loop()
        self.xserver = self._create_xserver()
        self.xclient = self._create_xclient()
        self.websockify = self._create_websockify()
        self.started = asyncio.wait((
            self.xserver.started,
            self.xclient.started,
            self.websockify.started,
        ), loop=self.loop, return_when=asyncio.ALL_COMPLETED)

    def _create_xserver(self):
        """
        Start the X server and return when it is ready to accept connections
        from X clients
        """
        cmd = (self.xserver_path, "-ac",
               "-geometry", self.desktop_geometry,
               "-desktop", self.desktop_title,
               "-SecurityTypes", "None",
               "-localhost",
               ":{}".format(self.display_number))
        return Xserver(cmd, loop=self.loop)

    def _create_xclient(self):
        """
        Start the X client
        """
        env = dict(os.environ)
        env["DISPLAY"] = ":{}".format(self.display_number)
        def _preexec():
            signal.signal(signal.SIGINT, signal.SIG_IGN)
        if self.config.service.syslog_identifier is None:
            self.config.service.syslog_identifier = "xclient"
        return SimpleProcess(self.config, preexec_fn=_preexec, env=env, loop=self.loop)

    def _create_websockify(self):
        """
        Start websockify to export the X client connection via a websocket
        server
        """
        cmd = ("websockify",
               "--run-once",
               "--web", "/usr/share/novnc/",
               str(self.websocket_listen_port),
               "localhost:{}".format(5900 + self.display_number))
        return Websockify(cmd, self.websocket_listen_port, loop=self.loop)

    @asyncio.coroutine
    def run(self):
        """
        Wait until any one of the X server, X application or websocket proxy
        quits, then make sure all the others quit as well
        """
        pool = ProcessPool(loop=self.loop)
        pool.set_quit_signal(signal.SIGINT)
        yield from pool.start_sync(self.xserver)
        yield from pool.start_sync(self.xclient)
        yield from pool.start_sync(self.websockify)
        yield from pool.run()


def start_everything(config, args):
    runner = RemoteApplication(
            config=config,
            websocket_listen_port=args.port,
            desktop_title=args.title,
            desktop_geometry=args.geometry,
            desktop_display=args.display)

    loop = asyncio.get_event_loop()
    try:
        log.debug("Starting processes")
        task = loop.create_task(runner.run())

        loop.run_until_complete(runner.started)
        log.info("Ready for connections, interrupt with ^C")

        connect_url = "http://localhost:{port}/vnc.html?host=localhost&port={port}&autoconnect=true".format(port=runner.websocket_listen_port)
        log.info("Connect using %s", connect_url)

        print(json.dumps({
            "url": connect_url,
        }))
        sys.stdout.close()

        if args.open:
            import webbrowser
            webbrowser.open(connect_url)

        if args.daemon:
            devnull_fd = os.open("/dev/null", os.O_RDWR)
            os.dup2(devnull_fd, 0)
            os.dup2(devnull_fd, 1)
            os.dup2(devnull_fd, 2)
            os.umask(0o27)

        loop.run_until_complete(task)
    finally:
        loop.close()


def main():
    parser = argparse.ArgumentParser(
            description="start X client on a private X server exported via VNC on the web",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")
    parser.add_argument("--logfile", action="store", help="lot to the given file")
    parser.add_argument("--geometry", action="store", default=DEFAULT_GEOMETRY, help="X display geometry")
    parser.add_argument("--display", action="store", type=int, default=DEFAULT_DISPLAY, help="X display number")
    parser.add_argument("--title", action="store", default="Desktop session", help="desktop session title")
    parser.add_argument("--port", action="store", type=int, default=6080, help="websocket server port")
    parser.add_argument("--open", action="store_true", help="open application in browser")
    parser.add_argument("--daemon", action="store_true", help="daemonize")
    parser.add_argument("--service", action="store_true", help="argument is a .service file rather than a command line")
    parser.add_argument("cmd", nargs="+", help="command and arguments to run")

    args = parser.parse_args()

    log_format = "%(asctime)-15s %(levelname)s %(message)s"
    level = logging.WARN
    if args.debug:
        level = logging.DEBUG
    elif args.verbose:
        level = logging.INFO
    if args.logfile:
        logging.basicConfig(level=level, filename=args.logfile, format=log_format)
    else:
        logging.basicConfig(level=level, stream=sys.stderr, format=log_format)

    if args.service:
        if len(args.cmd) != 1:
            raise Fail("When using --service only provide one argument: the pathname to the .service file")
        config = unitd.config.Config.read_file(args.cmd[0])
    else:
        config = unitd.config.Config()
        config.service.exec_start.append(args.cmd)

    if args.daemon:
        fd_r, fd_w = os.pipe()
        pid = os.fork()
        if pid != 0:
            os.dup2(fd_r, 0)
            os.close(fd_w)
            # Parent process
            # Wait for child
            shutil.copyfileobj(sys.stdin, sys.stdout)
            return
        os.dup2(fd_w, 1)
        os.close(fd_w)

    if args.daemon:
        try:
            os.setsid()
        except PermissionError:
            pass
        os.chdir("/")

    start_everything(config, args)


if __name__ == "__main__":
    try:
        main()
    except Fail as e:
        print(e, file=sys.stderr)
        sys.exit(1)
    except:
        log.exception("uncaught exception")
